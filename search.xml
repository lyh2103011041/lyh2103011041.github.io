<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python内存管理机制</title>
      <link href="/2022/11/04/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/11/04/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Python内存管理机制"><a href="#Python内存管理机制" class="headerlink" title="Python内存管理机制"></a>Python内存管理机制</h1><p>python话说会自己管理内存，实际上，对于占用很大内存的对象，并不会马上释放。举例，a&#x3D;range(10000*10000)，会发现内存飙升一个多G，del a 或者a&#x3D;[]都不能将内存降下来。</p><p>在IPython中用run运行程序，都是在独立的运行环境中运行，结束之后才将程序运行环境中的结果复制到IPython环境中，因此不会有变量被重复调用的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># del 可以删除多个变量，del a,b,c,d</span></span><br><span class="line"><span class="comment"># 办法：</span></span><br><span class="line"><span class="keyword">import</span> gc （garbage collector）</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">gc.collect()</span><br><span class="line"><span class="comment"># 马上内存就释放了。</span></span><br></pre></td></tr></table></figure><p>程序中应该避免对全局变量的依赖。你也可以在IPython下用此函数</p><h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1.垃圾回收"></a>1.垃圾回收</h2><p>python不像C++，Java等语言一样，他们可以不用事先声明变量类型而直接对变量进行赋值。对Python语言来讲，对象的类型和内存都是在运行时确定的。这也是为什么我们称Python语言为动态类型的原因（这里我们把动态类型可以简单的归结为对变量内存地址的分配是在运行时自动判断变量类型并对变量进行赋值）。</p><ul><li>当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个对象相互引用时，他们本身其他的引用已经为0了。</li><li>垃圾回收机制还有一个循环垃圾回收器, 确保释放循环引用对象(a引用b, b引用a, 导致其引用计数永远不为0)。</li></ul><p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p><p>由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p><h2 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2.引用计数"></a>2.引用计数</h2><p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p><p>Python采用了类似Windows内对象一样的方式来对内存进行管理。对于每一个对象，都维护这一个对指向该对对象的引用计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3.14</span></span><br><span class="line">y = x</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Yang\AppData\Roaming\Typora\typora-user-images\image-20221030100247506.png" alt="image-20221030100247506"></p><p>我们首先创建了一个对象3.14， 然后将这个浮点数对象的引用赋值给x，因为x是第一个引用，因此，这个浮点数对象的引用计数为1. 语句y &#x3D; x创建了一个指向同一个对象的引用别名y，我们发现，并没有为Y创建一个新的对象，而是将Y也指向了x指向的浮点数对象，使其引用计数为2.</p><p>变量a和变量b的id一致（我们可以将id值想象为c中变量的指针）</p><p>对于c语言来讲，我们创建了一个变量A时就会为该变量申请一个内存空间，并将变量值放入该空间当中，当将该变量赋给另一变量B时会为B申请一个新的内存空间，并将变量值放入到B的内存空间中，这也是为什么A和B的指针不一样的原因</p><p>而Python的情况却不一样，实际上，Python的处理方式和Javascript有点类似，如图所示，变量更像是附在对象上的标签(和引用的定义类似)。当变量被绑定在一个对象上的时候，该变量的引用计数就是1，(还有另外一些情况也会导致变量引用计数的增加),系统会自动维护这些标签，并定时扫描，当某标签的引用计数变为0的时候，该对就会被回收。</p><h2 id="3-内存池机制"><a href="#3-内存池机制" class="headerlink" title="3.内存池机制"></a>3.内存池机制</h2><p><img src="C:\Users\Yang\AppData\Roaming\Typora\typora-user-images\image-20221030101116266.png" alt="image-20221030101116266"></p><p>python的内存机制以金字塔行，-1 ，-2层主要有操作系统进行操作，</p><p>第0层是C中的malloc， free等内存分配和释放函数进行操作</p><p>第1层和第2层是内存池，有Python的接口函数PyMen_Malloc函数实现，当对象小于256k时有改层直接分配内存；</p><p>第3层是最上层，也就是我们对Python对象的直接操作</p><p>在c中如果频繁的调用malloc与free时，是会产生性能问题的。再加上平凡的分配与释放小块的内存会产生内存碎片。python在这里主要干的工作有</p><ul><li>如果请求分配的内存在1-256字节之间就使用自己的内存管理系统，否则直接使用malloc</li><li>这里还是会调用malloc分配内存，但每次会分配一块大小为256k的大块内存</li><li>经由内存池登记的内存到最后还是会回收到内存池,并不会调用 C 的 free 释放掉.以便下次使用.对于简单的Python对象，例如数值、字符串，元组（tuple不允许被更改)采用的是复制的方式(深拷贝?)，也就是说当将另一个变量B赋值给变量A时，虽然A和B的内存空间仍然相同，但当A的值发生变化时，会重新给A分配空间，A和B的地址变得不再相同</li><li>而对于像字典(dict)，列表(List)等，改变一个就会引起另一个的改变，也称之为浅拷贝</li></ul><h3 id="引用计数增加"><a href="#引用计数增加" class="headerlink" title="引用计数增加"></a>引用计数增加</h3><ul><li>对象被创建</li><li>另外的别人被创建</li><li>被作为参数传递给函数</li><li>作为容器对象的一个元素</li></ul><h3 id="引用计数减少"><a href="#引用计数减少" class="headerlink" title="引用计数减少"></a>引用计数减少</h3><ul><li><p>一个本地引用离开了它的作用域。比如一个函数结束时，x指向的对象引用减1</p></li><li><p>对象的别名被显示销毁</p></li><li><p>兑现的一个别名被赋值给其他对象</p></li><li><p>对象从一个窗口对象中移除</p></li><li><p>窗口对象本身被销毁：del myList， 或者窗口对象本身离开了作用域</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(getrefcount(a))b = aprint(getrefcount(b))</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(getrefcount(b))</span><br></pre></td></tr></table></figure><p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p><p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p><h3 id="对象引用对象"><a href="#对象引用对象" class="headerlink" title="对象引用对象"></a>对象引用对象</h3><p>python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">from_obj</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, to_obj</span>):</span><br><span class="line">        self.to_obj = to_obj</span><br><span class="line"></span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = from_obj(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a.to_obj))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure><p>可以看到，a引用了对象b。</p><p>对象引用对象，是Python最基本的构成方式。即使是a &#x3D; 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p><p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(getrefcount(a))</span><br><span class="line"></span><br><span class="line">b = [a, a]</span><br><span class="line"><span class="built_in">print</span>(getrefcount(a))</span><br></pre></td></tr></table></figure><p>由于对象b引用了两次a，a的引用计数增加了2。</p><p>当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p><p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p><p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="built_in">print</span>(gc.get_threshold())</span><br></pre></td></tr></table></figure><p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p><p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p><p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p><p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p><p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>标记-清除用来解决引用计数机制产生的循环引用，进而导致内存泄漏的问题 。循环引用只有在容器对象才会产生，比如字典，元组，列表等。</p><p>顾名思义，该机制在进行垃圾回收时分成了两步，分别是：</p><ul><li>标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达</li><li>清除阶段，再次遍历对象，如果发现某个对象没有标记为可达（即为Unreachable），则就将其回收</li></ul><p><strong>为了减少应用程序暂停的时间，Python 通过“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率。</strong></p><p><img src="C:\Users\Yang\AppData\Roaming\Typora\typora-user-images\image-20221030110305426.png" alt="image-20221030110305426"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体而言，python通过内存池来减少内存碎片化，提高执行效率。主要通过引用计数来完成垃圾回收，通过标记-清除解决容器对象循环引用造成的问题，通过分代回收提高垃圾回收的效率。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
